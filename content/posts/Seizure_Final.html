---
title: "Epileptic Seizure Recognition with Deep Learning"
output:
  html_document:
    df_print: paged
---



<div id="introduction" class="section level3">
<h3>Introduction</h3>
<p>This project attempts to classify whether a patient is suffering from an epileptic seizure or not based on certain known features. The dataset was freely obtained from the following link: <a href="https://www.kaggle.com/harunshimanto/epileptic-seizure-recognition" class="uri">https://www.kaggle.com/harunshimanto/epileptic-seizure-recognition</a>. To summarise the data, the features comprise of individual data points of an EEG recording, monitoring a subjectâ€™s brain activity at different points in time. Further details about the specifications of these variables can be found via the given link. The data consists of 178 explanatory variables, labeled X1, X2,â€¦â€¦,X178, and the target variable is simply called y. The target variable comprises of 5 classes, highlighting the following information:</p>
<p>5 - eyes open, meaning when they were recording the EEG signal of the brain the patient had their eyes open</p>
<p>4 - eyes closed, meaning when they were recording the EEG signal the patient had their eyes closed</p>
<p>3 - they identified where the region of the tumor was in the brain and recorded the EEG activity from the healthy brain area</p>
<p>2 - they recorded the EEG from the area where the tumor was located</p>
<p>1 - recording of seizure activity</p>
<p>To summarise, only class 1 indicates any presence of seizures, while the other 4 classes can be considered as the absence of seizures. With 178 features, there are 11500 rows of information, making this a reasonable sized dataset for applying deep learning techniques. The Tensorflow library is utilised here to construct a simple deep neural network for classification (multi-layer perceptron). In order to compare the performance of the neural network with other models, a series of ensemble methods and a logistic regression is also applied to examine any change in performance. This analysis is carried out in Python.</p>
<p>Before beginning, first the required libraries are loaded.</p>
<pre class="python"><code>#importing libraries

import matplotlib
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
from imblearn.under_sampling import RandomUnderSampler
from collections import Counter
import sklearn
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.metrics import roc_curve
from tensorflow.keras.utils import to_categorical
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense
from pycaret.classification import *
import warnings
warnings.filterwarnings(&quot;ignore&quot;)</code></pre>
</div>
<div id="exploring-and-processing" class="section level3">
<h3>Exploring and Processing</h3>
<p>Before moving forward to building the neural network, first some preprocessing and exploring of the data is carried out. Classes 2,3,4 and 5 are replaced with 0, indicating a singular class representing no seizure activity. This simplifies the data a bit as it is now a simple binary classification problem. However, with this conversion, there is now a severe class imbalance, which is shown below.</p>
<pre class="python"><code>#Initial preprocessing and exploring

#for reproducibility
np.random.seed(1234)

#Load Data
seizure = pd.read_csv(&#39;Epileptic-Seizure-Recognition.csv&#39;)

#remove first column
seizure = seizure.loc[:, ~seizure.columns.str.contains(&#39;^Unnamed&#39;)]

#replace all other classes with 0 to indicate no seizure
seizure.y = seizure.y.replace({2:0, 3:0, 4:0, 5:0})</code></pre>
<pre class="python"><code>#visualizing class imbalance

# sns.countplot(seizure.y, label = &#39;Class Imbalance&#39;)
# plt.title(&#39;Class Imbalance&#39;)
# print(seizure.y.value_counts())</code></pre>
<div class="figure">
<img src="/images/Class_Imbalance.png" alt="" />
<p class="caption">Class Imbalance Plot</p>
</div>
<p>In such a case of imbalanced classes, it is important that there should be some attempt to balance the data, otherwise any performance metrics generated by the models will be highly misleading as the model will be heavily biased towards to the majority class. As there is ample data available, undersampling is a useful technique that can be used here to randomly select observations from the majority class (0) equal to the number of minority class (1) observations. From 11500 original observations, there are now 4600 observations left to build the model on, which is still reasonable, as the number of features is still well below the number of observations.</p>
<pre class="python"><code>#create input and output categories for tensorflow
X = seizure.loc[:, seizure.columns != &#39;y&#39;]
y = seizure.loc[:, &#39;y&#39;]

#convert output to categorical
y = to_categorical(y)

#balance classes by random undersampling
undersample = RandomUnderSampler(sampling_strategy = &#39;majority&#39;)
X_under, y_under = undersample.fit_resample(X, y)

#train_test split
X_train, X_test, Y_train, Y_test = train_test_split(X_under, y_under, 
                                                    test_size = 0.2)

#scale the independent variables
X_train = sklearn.preprocessing.scale(X_train)
X_test = sklearn.preprocessing.scale(X_test)</code></pre>
</div>
<div id="building-the-nn-model-via-tensorflow" class="section level3">
<h3>Building the NN model via Tensorflow</h3>
<p>Having processed the data, it is now time to build the neural network model. Initially, the data is split into training and testing partitions (80/20 split). To reach a reasonable level of depth, 3 hidden layers are used, each with an approximately proportional decrease in the number of neurons available to allow smooth convergence from 178 input nodes to 2 output nodes (representing the 2 classes). Since this is a classification task, the sigmoid activation function is generally preferred for the output layer, and accuracy is used as the performance metric. The number of epochs is set to let the model undergo 100 iterations over the entire dataset.</p>
<pre class="python"><code>#A deep NN model
model_d = Sequential()
model_d.add(Dense(120, activation = &#39;relu&#39;, input_dim = 178))
model_d.add(Dense(90, activation = &#39;relu&#39;))
model_d.add(Dense(40, activation = &#39;relu&#39;))
model_d.add(Dense(1, activation = &#39;sigmoid&#39;))
model_d.compile(optimizer = &#39;adam&#39;, loss = &#39;binary_crossentropy&#39;,
                metrics = [&#39;accuracy&#39;])
model_d.fit(X_train, Y_train, epochs = 100, verbose = 0)</code></pre>
<pre><code>## &lt;tensorflow.python.keras.callbacks.History object at 0x0000000038F3DF48&gt;</code></pre>
<p>Once the model is run, the performance over both the training and testing set is noted.</p>
<pre class="python"><code>#Training set accuracy
scores_d = model_d.evaluate(X_train, Y_train, verbose=False)
print(&quot;Training Accuracy: %.2f%%\n&quot; % (scores_d[1]*100))</code></pre>
<pre><code>## Training Accuracy: 100.00%</code></pre>
<pre class="python"><code>#Testing set accuracy
scores_d = model_d.evaluate(X_test, Y_test, verbose=False)
print(&quot;Testing Accuracy: %.2f%%\n&quot; % (scores_d[1]*100))</code></pre>
<pre><code>## Testing Accuracy: 96.20%</code></pre>
<p>The training set achieves a spectacular 100% accuracy. However, this may be too good to be true, as overfitting is a possibility. The testing set accuracy confirms this, reaching a lower value of about 95%. This is still a very good result from just a simple model put together. The performance is further emphasised by the ROC curve, which closely resembles that of a perfect model. Perhaps with further hyperparameter tuning, a more detailed and potentially even deeper model can be created to improve accuracy even further.</p>
<pre class="python"><code>#ROC curve

# y_test_pred_probs_d = model_d.predict(X_test)
# FPR_d, TPR_d, _ = roc_curve(Y_test, y_test_pred_probs_d)
# plt.plot(FPR_d, TPR_d)
# plt.plot([0,1],[0,1],&#39;--&#39;, color=&#39;black&#39;) #diagonal line
# plt.title(&#39;ROC Curve&#39;)
# plt.xlabel(&#39;False Positive Rate&#39;)
# plt.ylabel(&#39;True Positive Rate&#39;)
# plt.show()
# plt.clf()</code></pre>
<div class="figure">
<img src="/images/ROC_DNN.png" alt="" />
<p class="caption">ROC for the Neural Network</p>
</div>
</div>
<div id="other-methods" class="section level3">
<h3>Other Methods</h3>
<p>Before prematurely deciding that deep neural networks are the greatest thing ever and should be used everywhere all the time, it is worth investigating whether similar results can be achieved with other models. This is because neural networks are generally one of the least interpretable methods used, and while obtaining the highest possible accuracy is a worthy goal, understanding what the model is actually even doing is also important. Good model understanding will enable the right method being used in the right situation, as opposed to blindly plugging in the most complex method.</p>
<p>In order to make this comparison, the PyCaret package is used, as it implements several popular machine learning methods quickly and easily. First, the data is combined to form a single dataframe once again for the package to process.</p>
<pre class="python"><code>#combine X_under and y_under into a single array
seizure_arr = np.concatenate([X_under,y_under], axis = 1)

#convert the array back into a data frame
seizure_df = pd.DataFrame(seizure_arr)

#setting original column names
seizure_df.columns = seizure.columns

#had to apparently convert to categorical again for the models to run
seizure_df.y = to_categorical(seizure_df.y)</code></pre>
<p>After some brief preprocessing, the PyCaret package is initialized. Do note that the code at some points is shown with a â€™ # â€™ symbol preceding each command. This is only done as there are some rendering issues between python plots and R Markdown (on which these reports are made). The â€™ # â€™ symbol is not necessary if the actual code is being run.</p>
<p>The environment is setup, with a default train-test split of 70/30 (refer to the PyCaret documentation for further details). The two methods being used here are the simple Logistic Regression as a benchmark, and a series of ensemble techniques including Extreme Gradient Boosting and Random Forests. The accuracy results for each method are shown below.</p>
<pre class="python"><code>#setup for pycaret
seizure_pc = setup(seizure_df, target = &#39;y&#39;, html = False, silent = True, verbose=False, normalize = True)</code></pre>
<pre><code>## [2K
[2K
[2K
[2K</code></pre>
<pre class="python"><code>#run simple logistic regression as benchmark
seizure_logistic = create_model(&#39;lr&#39;)</code></pre>
<pre><code>## [2K
[2K
      Accuracy     AUC  Recall   Prec.      F1   Kappa     MCC
## 0       0.6087  0.5391  0.7516  0.5845  0.6576  0.2174  0.2268
## 1       0.6366  0.5805  0.7640  0.6089  0.6777  0.2733  0.2826
## 2       0.5901  0.5218  0.7329  0.5700  0.6413  0.1801  0.1880
## 3       0.6025  0.4986  0.7888  0.5747  0.6649  0.2050  0.2209
## 4       0.5963  0.5106  0.7702  0.5714  0.6561  0.1925  0.2054
## 5       0.6149  0.5672  0.7391  0.5920  0.6575  0.2298  0.2373
## 6       0.6304  0.5479  0.8385  0.5921  0.6941  0.2609  0.2869
## 7       0.6087  0.5024  0.8199  0.5764  0.6769  0.2174  0.2398
## 8       0.6149  0.5218  0.7888  0.5853  0.6720  0.2298  0.2451
## 9       0.6324  0.5622  0.7578  0.6070  0.6740  0.2642  0.2728
## Mean    0.6136  0.5352  0.7752  0.5862  0.6672  0.2270  0.2406
## SD      0.0148  0.0271  0.0324  0.0131  0.0141  0.0296  0.0309</code></pre>
<pre class="python"><code>#run ensemble models
seizure_ensemble = compare_models(whitelist = models(type=&#39;ensemble&#39;).index.tolist(), fold = 3)</code></pre>
<pre><code>## [2K
[2K
                             Model  Accuracy     AUC  Recall   Prec.      F1  \
## 0           Extra Trees Classifier    0.9615  0.9934  0.9621  0.9611  0.9615   
## 1  Light Gradient Boosting Machine    0.9568  0.9927  0.9578  0.9561  0.9569   
## 2              CatBoost Classifier    0.9546  0.9929  0.9640  0.9464  0.9551   
## 3        Extreme Gradient Boosting    0.9537  0.9919  0.9596  0.9485  0.9540   
## 4     Gradient Boosting Classifier    0.9453  0.9904  0.9640  0.9296  0.9464   
## 5         Random Forest Classifier    0.9435  0.9849  0.9193  0.9661  0.9421   
## 6             Ada Boost Classifier    0.9217  0.9773  0.9348  0.9113  0.9228   
## 
##     Kappa     MCC  TT (Sec)  
## 0  0.9230  0.9231    0.2560  
## 1  0.9136  0.9137    2.1463  
## 2  0.9093  0.9095   40.2411  
## 3  0.9074  0.9075    1.1034  
## 4  0.8906  0.8914    9.6551  
## 5  0.8869  0.8880    0.1172  
## 6  0.8434  0.8438    2.1115</code></pre>
<p>The Logistic Regression performed the worst, reaching a mean accuracy value of only approximately 60%. This is also illustrated by its ROC curve shown below.</p>
<pre class="python"><code># plot_model(seizure_logistic)</code></pre>
<div class="figure">
<img src="/images/ROC_log.png" alt="" />
<p class="caption">ROC for logistic regression</p>
</div>
<p>On the other hand, the Extra Tree Classifier from the ensemble methods has performed quite well, with an accuracy level almost equivalent to that of the Neural Network. This is illustrated by the equally similar ROC curve generated below.</p>
<pre class="python"><code># plot_model(seizure_ensemble)</code></pre>
<div class="figure">
<img src="/images/ROC_Ensemble.png" alt="" />
<p class="caption">ROC for Ensembles</p>
</div>
</div>
<div id="conclusion" class="section level3">
<h3>Conclusion</h3>
<p>The above analysis has two important highlights. Firstly, deep learning techniques are incredibly powerful for use on complex data due to their inherent flexibility. With time as packages such as Tensorflow are being continously developed, implementing neural networks is gradually becoming easier and more efficient. Secondly, it should be noted that just because they are complex, neural networks may not always be the answer, as just like any other model, they have their shortcomings (adversarial machine learning comes to mind). Also, it is highly likely that given a particular use-case, there may be a number of models that provide equally promising results. The decision regarding which model to use therefore depends on the particular situation and goal of the analysis itself.</p>
</div>
